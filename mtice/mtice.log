LEGEND:
- DONE: something that has been specified in the subject and (I believe) has been fully implemented
- TODO: something that has been considered but not yet implemented (you will see the keywords TODO and UNIMPLEMENTED in my code for these situations)


PARSING TODO (based on subject):
- prompt & prompt history (readline in main.c)
- make sure that the executables exist in PATH
- receive signals
- handle quotes (then, the correct string will be stored in the t_token struct and passed on to execution)
- store redirections in struct t_redir (implementing redirection, appending && here_doc should be done in exec)
- split the input into processes according to pipes
- expansion of environment variables: should this be done in execution or in parsing?
- catching errors in the input (e.g. command that does not exist, incorrect path, etc.): should this be done in execution or in parsing?
- handle $?
- handle ctrl-C, ctrl-D, ctrl-\ (will leave this to the end, we can see who has time to implement)


PARSING WALKTHROUGH:
(Notes: ABOUT NOT EXITING AND RETURNING TO THE MAIN: we should be able to set the ernno value ourselves, to the same value that bash would return when there is an error. Therefore, we can treat errno like a global variable (which it is not) and when ernno != 0 we can simply return to the main function. We must check within every function if the errno value is 0 or not. I still have to implement readline history, because at the moment when you try to find the errno of the previous process that was run, the computer will always say it is 0. Check out the errno library, to see out to assign errno value. For example, "catnip -e" would return "catnip: command not found" and then if you run "$?" it will give you "127: command not found", errno has to be set to ernno = EKEYEXPIRED)

File: main.c
Contains the main of the whole program.
TODO: finish readline and readline history.
TODO: figure out how to return to the main when there is an error detected

File: parsing_main.c
Contains what is the "main" for the whole of the parsing process. This is the function that you can see that is called in the actual main of the program. When parsing() returns, it re-enters the main loop in main.c.

File: input_check.c
Contains functions that check the input for syntax errors before it is broken down into processes.
Checks for unclosed double quotes, unclosed single quotes, multiple pipes in a row, pipes at the end of the process, redirect syntax errors.

File: envp
Copy of envp here for future use. Stored in struct t_data *all. Use this copy to access any enviroment path variables, to check if the path is valid etc. You need to use this if you are performing anything such as unsetting the path, exporting a variable, etc.

File: lexing.c
Breaks down the input into processes and stores them in the t_proc struct (a pointer is stored in t_data *all).

File: tokenizer.c
Breaks down a process into tokens and assigns them their type. Stored in the t_token struct (a pointer is stored in t_data *all).

File: redir_check.c
Iterates through the struct t_token and checks for infiles and outfiles (creates them, checks if permissions are ok, if they exist etc.). If all goes well, opens all files and stores them in the t_redir struct (a pointer is stored in t_data *all).

File: parsing_utils.c
For now, a slightly unorganised combination of the utils I need for the creation and iteration through structs. (will organise at a later stage)

File: free_utils.c
For now, a slightly unorgansed combination of freeing functions.


STRUCT t_token
Should look like this
e.g. input: hello world! >out1 | <in2 cat -e | echo "   whaaat  " '|'

token: hello, type: 1 (command), process_nbr: 0
token: world, type: 2 (argument), process_nbr: 0
token: cat, type: 1 (command), process_nbr: 1
etc....
token: echo, type: 1, process_nbr: 2
token:     what    , type: 2, process_mbr: 2;
token: |, type: 2, process_nbr: 2


STRUCT t_redir
filename: out1, type: 4(RE_OUT), process_nbr: 0
filneame: in2, type: 5(RE_IN), process_nbr: 1
